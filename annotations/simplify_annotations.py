#!/usr/bin/env python3
# This script takes the input for the SC and MI classifier (which is then used to generate the TFRecord Files)
# simplifies the annotations by omitting MI label 1, 6 and 7 as described in chapter 4.2.3.1 of the thesis. Label 1
# is ommited as there is no annotated sample representing it and because it represents a completely rare case
# (cp. example 4.2.1 in the thesis). 
# Such a simpler annotation allows to state the MI labeling problem as a regression problem. Therefore, the remaining 
# labels will become subject to a permutation, to allow simpler handling later on. The permutation will be
# Original label:   0   5   4   3   2
#                   |   |   |   |   |
# New label:        0   1   2   3   4
# 
# The inputs are the sample files generated by 'generateClassifierInputWiki' and 'generateClassifierInputBBC'.

import argparse
import os
import json

if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument('--wiki', type=str, help="The file containing the annotated wiki samples.", default='wiki-anno-samples.jsonl')
  parser.add_argument('--bbc', type=str, help="The file containing the annotated bbc samples.", default='bbc-anno-samples.jsonl')
  parser.add_argument('--ext', type=str, help="A file extension that should be added to the modified input files.", default='-simple')
  args = parser.parse_args()
  
  wiki_samples_fn = args.wiki
  bbc_samples_fn = args.bbc
  extension = args.ext
  
  # the mapping from old to new labels
  mapping = {
    0: 0,
    5: 1,
    4: 2,
    3: 3,
    2: 4
  }

  if not os.path.isfile(wiki_samples_fn):
    raise(Exception('The file ' + wiki_samples_fn + ' does not exists'))
    
  if not os.path.isfile(bbc_samples_fn):
    raise(Exception('The file ' + bbc_samples_fn + ' does not exists'))
    
  # output file names
  wiki_fn, wiki_ext = os.path.splitext(wiki_samples_fn)  
  wiki_out_fn = wiki_fn + extension + wiki_ext
  
  bbc_fn, bbc_ext = os.path.splitext(bbc_samples_fn)  
  bbc_out_fn = bbc_fn + extension + bbc_ext
  
  print('The output file for wiki samples will be ' + wiki_out_fn)
  if os.path.isfile(wiki_out_fn):
    print('The file %s already exists and will be overwritten.' % (wiki_out_fn))  
  
  print('The output file for bbc samples will be ' + bbc_out_fn)
  if os.path.isfile(bbc_out_fn):
    print('The file %s already exists and will be overwritten.' % (bbc_out_fn))
  
  # read samples
  with open(wiki_samples_fn, 'r') as f:
    wiki_samples = [json.loads(line) for line in f]
  with open(bbc_samples_fn, 'r') as f:
    bbc_samples = [json.loads(line) for line in f]
    
  print()
  print('Read %d annotated bbc samples and %d annotated wiki samples.' % (len(bbc_samples), len(wiki_samples)))
  
  # Write samples that have valid MI samples (all except those having 1, 6 or 7 as label).
  # All other labels get asssigned to their new labeling according to the dict "mapping".
  skipped = 0
  wiki_n = 0
  bbc_n = 0
  with open(bbc_out_fn, 'w') as f:   
    for d in bbc_samples:
      if d['annotation']['mi'] < 6 and d['annotation']['mi'] != 1:
        bbc_n += 1
        d['annotation']['mi'] = mapping[d['annotation']['mi']]
        jsonLine = json.dumps(d)      
        f.write(jsonLine + '\n')
      else:
        skipped += 1
        
  with open(wiki_out_fn, 'w') as f:   
    for d in wiki_samples:
      if d['annotation']['mi'] < 6 and d['annotation']['mi'] != 1:
        wiki_n += 1
        d['annotation']['mi'] = mapping[d['annotation']['mi']]
        jsonLine = json.dumps(d)      
        f.write(jsonLine + '\n')
      else:
        skipped += 1
  
  print('Output contains %d annotated bbc samples and %d annotated wiki samples.' % (bbc_n, wiki_n))
  print('Skipped %d samples in total.' % (skipped))
  
